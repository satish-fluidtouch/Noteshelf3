// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: FTAnnotationModel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProtoBuffAnnotations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var annotations: [ProtoBuffAnnotation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StrokeAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var strokeName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var textName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProtoBuffAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Common annotation attrinutes
  var annotationType: Int64 = 0

  var strokWidth: Float = 0

  var penType: Int64 = 0

  var boundingRectX: Float = 0

  var boundingRectY: Float = 0

  var boundingRectWidth: Float = 0

  var boundingRectHeight: Float = 0

  var segmentCount: Int64 = 0

  var createdTimeInterval: Double = 0

  var modifiedTimeInterval: Double = 0

  var version: Int64 = 0

  var isReadOnly: Bool = false

  var segmentData: Data = Data()

  var strokeColor: Int64 = 0

  var extendedAttributes: ProtoBuffAnnotation.OneOf_ExtendedAttributes? = nil

  var stroke: StrokeAnnotation {
    get {
      if case .stroke(let v)? = extendedAttributes {return v}
      return StrokeAnnotation()
    }
    set {extendedAttributes = .stroke(newValue)}
  }

  var image: ImageAnnotation {
    get {
      if case .image(let v)? = extendedAttributes {return v}
      return ImageAnnotation()
    }
    set {extendedAttributes = .image(newValue)}
  }

  var text: TextAnnotation {
    get {
      if case .text(let v)? = extendedAttributes {return v}
      return TextAnnotation()
    }
    set {extendedAttributes = .text(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExtendedAttributes: Equatable {
    case stroke(StrokeAnnotation)
    case image(ImageAnnotation)
    case text(TextAnnotation)

  #if !swift(>=4.1)
    static func ==(lhs: ProtoBuffAnnotation.OneOf_ExtendedAttributes, rhs: ProtoBuffAnnotation.OneOf_ExtendedAttributes) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stroke, .stroke): return {
        guard case .stroke(let l) = lhs, case .stroke(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ProtoBuffAnnotations: @unchecked Sendable {}
extension StrokeAnnotation: @unchecked Sendable {}
extension ImageAnnotation: @unchecked Sendable {}
extension TextAnnotation: @unchecked Sendable {}
extension ProtoBuffAnnotation: @unchecked Sendable {}
extension ProtoBuffAnnotation.OneOf_ExtendedAttributes: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoBuffAnnotations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoBuffAnnotations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoBuffAnnotations, rhs: ProtoBuffAnnotations) -> Bool {
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StrokeAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StrokeAnnotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strokeName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.strokeName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.strokeName.isEmpty {
      try visitor.visitSingularStringField(value: self.strokeName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StrokeAnnotation, rhs: StrokeAnnotation) -> Bool {
    if lhs.strokeName != rhs.strokeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageAnnotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imageName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageName.isEmpty {
      try visitor.visitSingularStringField(value: self.imageName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageAnnotation, rhs: ImageAnnotation) -> Bool {
    if lhs.imageName != rhs.imageName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextAnnotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "textName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.textName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.textName.isEmpty {
      try visitor.visitSingularStringField(value: self.textName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextAnnotation, rhs: TextAnnotation) -> Bool {
    if lhs.textName != rhs.textName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoBuffAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoBuffAnnotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotationType"),
    2: .same(proto: "strokWidth"),
    3: .same(proto: "penType"),
    4: .same(proto: "boundingRectX"),
    5: .same(proto: "boundingRectY"),
    6: .same(proto: "boundingRectWidth"),
    7: .same(proto: "boundingRectHeight"),
    8: .same(proto: "segmentCount"),
    9: .same(proto: "createdTimeInterval"),
    10: .same(proto: "ModifiedTimeInterval"),
    11: .same(proto: "version"),
    12: .same(proto: "isReadOnly"),
    13: .same(proto: "segmentData"),
    14: .same(proto: "strokeColor"),
    15: .same(proto: "stroke"),
    16: .same(proto: "image"),
    17: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.annotationType) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.strokWidth) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.penType) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.boundingRectX) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.boundingRectY) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.boundingRectWidth) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.boundingRectHeight) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.segmentCount) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.createdTimeInterval) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.modifiedTimeInterval) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.isReadOnly) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.segmentData) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.strokeColor) }()
      case 15: try {
        var v: StrokeAnnotation?
        var hadOneofValue = false
        if let current = self.extendedAttributes {
          hadOneofValue = true
          if case .stroke(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.extendedAttributes = .stroke(v)
        }
      }()
      case 16: try {
        var v: ImageAnnotation?
        var hadOneofValue = false
        if let current = self.extendedAttributes {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.extendedAttributes = .image(v)
        }
      }()
      case 17: try {
        var v: TextAnnotation?
        var hadOneofValue = false
        if let current = self.extendedAttributes {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.extendedAttributes = .text(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.annotationType != 0 {
      try visitor.visitSingularInt64Field(value: self.annotationType, fieldNumber: 1)
    }
    if self.strokWidth != 0 {
      try visitor.visitSingularFloatField(value: self.strokWidth, fieldNumber: 2)
    }
    if self.penType != 0 {
      try visitor.visitSingularInt64Field(value: self.penType, fieldNumber: 3)
    }
    if self.boundingRectX != 0 {
      try visitor.visitSingularFloatField(value: self.boundingRectX, fieldNumber: 4)
    }
    if self.boundingRectY != 0 {
      try visitor.visitSingularFloatField(value: self.boundingRectY, fieldNumber: 5)
    }
    if self.boundingRectWidth != 0 {
      try visitor.visitSingularFloatField(value: self.boundingRectWidth, fieldNumber: 6)
    }
    if self.boundingRectHeight != 0 {
      try visitor.visitSingularFloatField(value: self.boundingRectHeight, fieldNumber: 7)
    }
    if self.segmentCount != 0 {
      try visitor.visitSingularInt64Field(value: self.segmentCount, fieldNumber: 8)
    }
    if self.createdTimeInterval != 0 {
      try visitor.visitSingularDoubleField(value: self.createdTimeInterval, fieldNumber: 9)
    }
    if self.modifiedTimeInterval != 0 {
      try visitor.visitSingularDoubleField(value: self.modifiedTimeInterval, fieldNumber: 10)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 11)
    }
    if self.isReadOnly != false {
      try visitor.visitSingularBoolField(value: self.isReadOnly, fieldNumber: 12)
    }
    if !self.segmentData.isEmpty {
      try visitor.visitSingularBytesField(value: self.segmentData, fieldNumber: 13)
    }
    if self.strokeColor != 0 {
      try visitor.visitSingularInt64Field(value: self.strokeColor, fieldNumber: 14)
    }
    switch self.extendedAttributes {
    case .stroke?: try {
      guard case .stroke(let v)? = self.extendedAttributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .image?: try {
      guard case .image(let v)? = self.extendedAttributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .text?: try {
      guard case .text(let v)? = self.extendedAttributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoBuffAnnotation, rhs: ProtoBuffAnnotation) -> Bool {
    if lhs.annotationType != rhs.annotationType {return false}
    if lhs.strokWidth != rhs.strokWidth {return false}
    if lhs.penType != rhs.penType {return false}
    if lhs.boundingRectX != rhs.boundingRectX {return false}
    if lhs.boundingRectY != rhs.boundingRectY {return false}
    if lhs.boundingRectWidth != rhs.boundingRectWidth {return false}
    if lhs.boundingRectHeight != rhs.boundingRectHeight {return false}
    if lhs.segmentCount != rhs.segmentCount {return false}
    if lhs.createdTimeInterval != rhs.createdTimeInterval {return false}
    if lhs.modifiedTimeInterval != rhs.modifiedTimeInterval {return false}
    if lhs.version != rhs.version {return false}
    if lhs.isReadOnly != rhs.isReadOnly {return false}
    if lhs.segmentData != rhs.segmentData {return false}
    if lhs.strokeColor != rhs.strokeColor {return false}
    if lhs.extendedAttributes != rhs.extendedAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
